(function () {
			"use strict";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function createCtx(callback, elm, ctx) {
  if (callback === undefined) return [[]];

  function state(input) {
    switch (_typeof(input)) {
      case 'string':
        {
          if (!input) return ctx && ctx[''][1][''];

          var _ref = refs[input] || [],
              _ref2 = _slicedToArray(_ref, 3),
              node = _ref2[1],
              type = _ref2[2];

          return typeof type === 'function' ? node[''] : node;
        }

      case 'undefined':
        return object;

      case 'object':
        break;

      default:
        return;
    }

    Object.assign(object, input);
    trigger(memory, elm);
  }

  var object = {};
  var refs = {
    '': state
  };
  var memory = {
    '': [, refs, callback]
  };
  return memory;
}

function createElm(tag, _ref3) {
  var _ref3$ = _slicedToArray(_ref3[''], 4),
      _ref3$$ = _ref3$[3],
      nodes = _ref3$$ === void 0 ? [] : _ref3$$;

  var node, childNodes;

  if (nodes.length) {
    while (nodes.length) {
      node = nodes.pop();

      if (node instanceof Element) {
        childNodes = _toConsumableArray(node.childNodes).filter(function (_ref4) {
          var nodeType = _ref4.nodeType;
          return nodeType !== Node.COMMENT_NODE;
        });
        break;
      }
    }
  } else {
    node = document.createElement(tag);
  }

  return {
    '': [[], node, tag, childNodes]
  };
}

function createTxt(text, _ref5) {
  var _ref5$ = _slicedToArray(_ref5[''], 4),
      _ref5$$ = _ref5$[3],
      nodes = _ref5$$ === void 0 ? [] : _ref5$$;

  var node;

  if (!nodes.length) {
    node = document.createTextNode(text);
  } else if (nodes[nodes.length - 1] instanceof Text) {
    node = nodes.pop();
  }

  return {
    '': [text, node]
  };
}

function forget(memory, elm) {
  if (typeof memory === 'function') return memory();
  if (_typeof(memory) !== 'object') return;

  var _elm = elm,
      _elm$ = _slicedToArray(_elm[''], 2),
      container = _elm$[1];

  var _memory$ = _slicedToArray(memory[''], 2),
      fragment = _memory$[0],
      node = _memory$[1];

  if (node instanceof Element || node instanceof Text) elm = memory;

  if (Array.isArray(fragment)) {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = fragment[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var _memory = _step.value;
        forget(_memory, elm);
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  }

  if (elm === memory) container.removeChild(node);
}

function locate(children) {
  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = children[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var memory = _step2.value;
      if (_typeof(memory) !== 'object') continue;

      var _memory$2 = _slicedToArray(memory[''], 2),
          fragment = _memory$2[0],
          node = _memory$2[1];

      if (node instanceof Element || node instanceof Text) {
        return node;
      } else {
        return locate(fragment);
      }
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
        _iterator2["return"]();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }
}

var cache = new WeakMap();

function parse(strings) {
  return; // TODO: add tagged templates for JSX-like authoring
}

function reconcile(memory, elm, content, ctx, sibling, hydrating) {
  var _memory$3 = _slicedToArray(memory[''], 1),
      prevContent = _memory$3[0];

  var _elm$2 = _slicedToArray(elm[''], 2),
      container = _elm$2[1];

  var removals = new Set(prevContent);
  removals["delete"](undefined);

  for (var i = content.length - 1; i >= 0; i--) {
    var child = content[i];

    if (!child && child !== 0 || child === true) {
      prevContent[i] = undefined;
      continue;
    } else if (Array.isArray(child)) {
      child = client.apply(void 0, ['', {}].concat(_toConsumableArray(child)));
    } else if (typeof child !== 'function') {
      child = client(child);
    }

    var prev = prevContent[i];
    child = prevContent[i] = child(memory, elm, i, ctx, sibling, hydrating);

    var _child = child,
        _child$ = _slicedToArray(_child[''], 2),
        fragment = _child$[0],
        node = _child$[1];

    if ((fragment || fragment === 0) && !hydrating) {
      if (node instanceof Element || node instanceof Text) {
        if (child !== prev) {
          if (sibling) container.insertBefore(node, sibling);else container.appendChild(node);
        }

        sibling = node;
      } else {
        sibling = locate(fragment) || sibling;
      }
    }

    removals["delete"](child);
  }

  var _iteratorNormalCompletion3 = true;
  var _didIteratorError3 = false;
  var _iteratorError3 = undefined;

  try {
    for (var _iterator3 = removals[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
      var _memory2 = _step3.value;
      forget(_memory2, elm);
    }
  } catch (err) {
    _didIteratorError3 = true;
    _iteratorError3 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
        _iterator3["return"]();
      }
    } finally {
      if (_didIteratorError3) {
        throw _iteratorError3;
      }
    }
  }
}

var registry = new Map();
var queue = [];

function trigger(memory, elm, state) {
  var depth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : -1;
  if (depth < 0) state = memory[''][1][''];
  if (state) return trigger(memory, elm, state(''), depth + 1);
  var map = queue[depth];
  state = memory[''][1][''];

  if (!queue.length) {
    setTimeout(function () {
      while (queue.length) {
        map = queue.shift();
        if (!map) continue;
        var _iteratorNormalCompletion4 = true;
        var _didIteratorError4 = false;
        var _iteratorError4 = undefined;

        try {
          for (var _iterator4 = map.values()[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
            var callback = _step4.value;
            callback();
          }
        } catch (err) {
          _didIteratorError4 = true;
          _iteratorError4 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
              _iterator4["return"]();
            }
          } finally {
            if (_didIteratorError4) {
              throw _iteratorError4;
            }
          }
        }

        map.clear();
      }

      registry.clear();
    }, 0);
  }

  if (registry.has(state)) return;else if (!map) map = queue[depth] = new Map();
  registry.set(state, map);
  map.set(state, function () {
    var content = updateCtx(memory);

    var _elm$3 = _slicedToArray(elm[''], 1),
        children = _elm$3[0];

    var index = children.indexOf(memory);
    var sibling = ~index ? locate(children.slice(index + 1)) : undefined;
    reconcile(memory, elm, content, memory, sibling);
  });
}

function escape(string) {
  if (typeof string !== 'string') return string;
  return string.replace(/[&<>"']/g, function (match) {
    switch (match) {
      case '&':
        return '&amp;';

      case '<':
        return '&lt;';

      case '>':
        return '&gt;';

      case '"':
        return '&quot;';

      case '\'':
        return '&#39;';
    }
  });
}

function flatten(content) {
  var all = [];
  var _iteratorNormalCompletion5 = true;
  var _didIteratorError5 = false;
  var _iteratorError5 = undefined;

  try {
    for (var _iterator5 = content[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
      var it = _step5.value;
      if (Array.isArray(it)) all.push.apply(all, _toConsumableArray(flatten(it)));else if (typeof it === 'string') all.push(it);
    }
  } catch (err) {
    _didIteratorError5 = true;
    _iteratorError5 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion5 && _iterator5["return"] != null) {
        _iterator5["return"]();
      }
    } finally {
      if (_didIteratorError5) {
        throw _iteratorError5;
      }
    }
  }

  return all;
}

var singletons = ['wbr', 'track', 'source', 'param', 'meta', 'link', 'keygen', 'input', 'img', 'hr', 'embed', 'command', 'col', 'br', 'base', 'area', '!doctype'];

function server(type) {
  for (var _len = arguments.length, content = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    content[_key - 1] = arguments[_key];
  }

  var customized = typeof type === 'function';
  var textual = !customized && !content.length;

  var _ref6 = content.shift() || {},
      key = _ref6[''],
      props = _objectWithoutProperties(_ref6, [""]);

  var tags = [];

  if (customized) {
    var state;

    props[''] = function (input) {
      if (_typeof(input) !== 'object') return state || {};
      return state = state || input;
    };

    content = type(props, content || []);
    if (!Array.isArray(content)) content = [content];
  } else if (textual) {
    return !type && type !== 0 || type === true ? '' : escape(type);
  } else if (type !== '') {
    var attributes = Object.entries(props).reduce(function (all, _ref7) {
      var _ref8 = _slicedToArray(_ref7, 2),
          name = _ref8[0],
          value = _ref8[1];

      if (name.startsWith('on')) {
        value = 'javascript:void(0);';
      } else if (!/^[a-zA-Z0-9-_.]+$/.test(name) || !value && value !== '' && value !== 0) {
        return all;
      }

      if (name === 'style') {
        value = Object.entries(value).map(function (_ref9) {
          var _ref10 = _slicedToArray(_ref9, 2),
              name = _ref10[0],
              value = _ref10[1];

          if (!/^[a-zA-Z0-9-_.]+$/.test(name)) return '';
          return "".concat(name, ":").concat(escape(value), ";");
        }).join('');
      } else if (Array.isArray(value)) {
        value = value.filter(function (it) {
          return it && typeof it === 'string';
        }).join(' ');
      }

      return value === true ? "".concat(all, " ").concat(name) : "".concat(all, " ").concat(name, "=\"").concat(escape(value), "\"");
    }, '');
    tags.push("<".concat(type).concat(attributes, ">"));
    if (~singletons.indexOf(type)) content = undefined;else tags.push("</".concat(type, ">"));
  }

  if (Array.isArray(content)) tags.splice.apply(tags, [tags.length && 1, 0].concat(_toConsumableArray(flatten(content))));
  return tags.join('');
}

function updateCtx(memory, props, content) {
  var core = memory[''],
      prev = _objectWithoutProperties(memory, [""]);

  var _core = _slicedToArray(core, 4),
      fragment = _core[0],
      state = _core[1][''],
      type = _core[2],
      shortcut = _core[3];

  var entries = Object.entries(prev);

  if (!props) {
    props = prev;
    if (shortcut) content = shortcut();
  } else if (!fragment) {
    core[0] = [];
  } else if (entries.length === Object.keys(props).length && entries.every(function (_ref11) {
    var _ref12 = _slicedToArray(_ref11, 2),
        name = _ref12[0],
        value = _ref12[1];

    return value === props[name];
  })) {
    if (shortcut) shortcut(content);
    return fragment;
  }

  function callback() {
    if (!content && content !== 0 || content === true) return;

    for (var _len2 = arguments.length, params = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      params[_key2] = arguments[_key2];
    }

    var elm = params[0],
        direct = params[1],
        i = params[2];

    core[3] = function () {
      if (!arguments.length) return content;
      direct[''][0][i] = arguments.length <= 0 ? undefined : arguments[0];
      trigger(direct, elm);
    };

    if (typeof content === 'function') return content.apply(void 0, params);
    return client('', {}, content).apply(void 0, params);
  }

  if (registry.has(state)) registry.get(state)["delete"](state);
  core[3] = undefined;
  var result = type(_objectSpread({}, props, {
    '': state
  }), callback);
  if (Array.isArray(result)) return result;
  return result === undefined ? [] : [result];
}

function updateElm(memory, props) {
  var _memory$4 = _slicedToArray(memory[''], 2),
      node = _memory$4[1],
      prevProps = _objectWithoutProperties(memory, [""]);

  for (var _i2 = 0, _Object$keys = Object.keys(_objectSpread({}, prevProps, {}, props)); _i2 < _Object$keys.length; _i2++) {
    var name = _Object$keys[_i2];
    var value = props[name];
    var prevValue = prevProps[name];

    if (prevValue === value) {
      continue;
    } else if (name.startsWith('on')) {
      name = name.slice(2);
      if (prevValue) node.removeEventListener(name, prevValue);
      if (value) node.addEventListener(name, value);
    } else if (value === true) {
      node.toggleAttribute(name, true);
    } else if (!value && value !== '' && value !== 0) {
      node.removeAttribute(name);
    } else if (name === 'style') {
      var style = node.style;
      if (!prevValue) prevValue = {};

      for (var _i3 = 0, _Object$keys2 = Object.keys(_objectSpread({}, prevValue, {}, value)); _i3 < _Object$keys2.length; _i3++) {
        var _name = _Object$keys2[_i3];
        var rule = value[_name];
        if (rule !== prevValue[_name]) style[_name] = rule;
      }
    } else {
      if (Array.isArray(value)) {
        value = value.filter(function (it) {
          return it && typeof it === 'string';
        }).join(' ');
      }

      node.setAttribute(name, value);
    }
  }
}

function updateTxt(memory, content) {
  var _memory$5 = _slicedToArray(memory[''], 2),
      prev = _memory$5[0],
      node = _memory$5[1];

  if (content !== prev) node.nodeValue = memory[''][0] = content;
}

function client(type) {
  for (var _len3 = arguments.length, content = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
    content[_key3 - 1] = arguments[_key3];
  }

  if (Array.isArray(type)) parse.apply(void 0, [type].concat(_toConsumableArray(content)));
  var customized = typeof type === 'function';
  var textual = !customized && !content.length;

  var _ref13 = content.shift() || {},
      key = _ref13[''],
      props = _objectWithoutProperties(_ref13, [""]);

  return function (direct, elm) {
    var i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var ctx = arguments.length > 3 ? arguments[3] : undefined;
    var sibling = arguments.length > 4 ? arguments[4] : undefined;
    var hydrating = arguments.length > 5 ? arguments[5] : undefined;
    var root = !direct || direct instanceof Element || direct instanceof Text;

    if (root) {
      elm = {
        '': [[],,, [direct]]
      };

      if (direct) {
        hydrating = true;
        if (customized) elm = createElm('', elm);
      }

      direct = elm;
    }

    var memory = key && ctx ? ctx[''][1][key] : direct[''][0][i];

    if (!memory || textual && memory[''].length !== 2 || !textual && type !== (memory[''][2] || '')) {
      if (customized) memory = createCtx(type, elm, ctx);else if (textual) memory = createTxt(type, elm);else if (type !== '') memory = createElm(type, elm);else memory = {
        '': [[]]
      };
      if (key && ctx) ctx[''][1][key] = memory;
    }

    if (customized) {
      content = updateCtx(memory, props, content);
      ctx = memory;
    } else if (textual) {
      if (!type && type !== 0 || type === true) type = '';
      updateTxt(memory, type);
      content = undefined;
    } else if (type !== '') {
      updateElm(memory, props);
      elm = memory;
      sibling = undefined;
    }

    if (content) reconcile(memory, elm, content, ctx, sibling, hydrating);
    if (memory === elm) sibling = memory[''][1];
    Object.assign(memory, props);
    return root ? memory[''][1] : memory;
  };
}

var stew = (typeof document === "undefined" ? "undefined" : _typeof(document)) === 'object' ? client : server;

			if (typeof define === 'function' && define.amd) {
			define(function () { return stew; });
		} else if (typeof module !== 'undefined' && module.exports) {
			module.exports = stew;
		} else if (typeof window === 'object' && window.document) {
			window.stew = stew;
		}
		})();