(function () {
			"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _readOnlyError(name) { throw new Error("\"" + name + "\" is read-only"); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _toArray(arr) { return _arrayWithHoles(arr) || _iterableToArray(arr) || _nonIterableRest(); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function forget(memory, elm) {
  if (typeof memory === 'function') return memory();else if (_typeof(memory) !== 'object') return;

  var _elm = elm,
      _elm$ = _slicedToArray(_elm[''], 2),
      container = _elm$[1];

  var _memory$ = _slicedToArray(memory[''], 3),
      fragment = _memory$[0],
      node = _memory$[1],
      tag = _memory$[2];

  if ((node instanceof Element || node instanceof Text) && tag !== '') {
    elm = memory;
  }

  if (Array.isArray(fragment)) {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = fragment[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var _memory = _step.value;
        forget(_memory, elm);
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  }

  if (elm === memory) container.removeChild(node);
}

function locate(children) {
  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = children[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var memory = _step2.value;
      if (_typeof(memory) !== 'object') continue;

      var _memory$2 = _slicedToArray(memory[''], 2),
          content = _memory$2[0],
          node = _memory$2[1];

      if (node instanceof Element || node instanceof Text) {
        return node;
      } else {
        return locate(content);
      }
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
        _iterator2["return"]();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }
}

function reconcile(memory, content, elm, ctx, sibling) {
  var _memory$3 = _slicedToArray(memory[''], 3),
      prev = _memory$3[0],
      tag = _memory$3[2];

  var _elm$2 = _slicedToArray(elm[''], 4),
      container = _elm$2[1],
      nodes = _elm$2[3];

  var removals = new Set(prev);
  var backup = sibling;
  prev.splice(content.length);
  removals["delete"](undefined);

  for (var i = content.length - 1; i >= 0; i--) {
    var _backup = prev[i];
    var it = content[i];

    if (typeof it === 'function') {
      var _ref = ctx || {},
          _ref$ = _toArray(_ref['']),
          props = _objectWithoutProperties(_ref, [""]);

      it = it(_objectSpread({}, props, {
        '': _backup
      }));
    }

    if (!it && it !== 0 || it === true || typeof it === 'function') {
      prev[i] = it && it !== true ? it : undefined;
      continue;
    } else if (Array.isArray(it) || _typeof(it) !== 'object') {
      it = {
        '': [it, '', Array.isArray(it) ? '' : undefined]
      };
    }

    it = prev[i] = update(it, memory, i, elm, ctx, sibling);

    var _it = it,
        _it$ = _slicedToArray(_it[''], 2),
        fragment = _it$[0],
        node = _it$[1];

    if ((fragment || fragment === 0) && !nodes) {
      if (node instanceof Element || node instanceof Text) {
        if (it !== _backup) {
          if (sibling) container.insertBefore(node, sibling);else container.appendChild(node);
        }

        sibling = node;
      } else {
        sibling = locate(fragment) || sibling;
      }
    }

    removals["delete"](it);
  }

  if (tag === '') memory[''][1] = sibling !== backup ? sibling : undefined;else if (nodes && elm === memory) memory[''][3] = undefined;
  var _iteratorNormalCompletion3 = true;
  var _didIteratorError3 = false;
  var _iteratorError3 = undefined;

  try {
    for (var _iterator3 = removals[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
      var _memory2 = _step3.value;

      if (typeof _memory2 !== 'function') {
        console.log(_memory2, prev);
        forget(_memory2, elm);
      }
    }
  } catch (err) {
    _didIteratorError3 = true;
    _iteratorError3 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
        _iterator3["return"]();
      }
    } finally {
      if (_didIteratorError3) {
        throw _iteratorError3;
      }
    }
  }
}

var queue = [];

function trigger(memory, elm) {
  var _memory$4 = _slicedToArray(memory[''], 2),
      callback = _memory$4[1][''][''];

  var depth = callback();
  var map = queue[depth];

  if (!queue.length) {
    setTimeout(function () {
      while (queue.length) {
        if (!(map = queue.shift())) continue;
        var _iteratorNormalCompletion4 = true;
        var _didIteratorError4 = false;
        var _iteratorError4 = undefined;

        try {
          for (var _iterator4 = map.values()[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
            var _callback = _step4.value;

            _callback();
          }
        } catch (err) {
          _didIteratorError4 = true;
          _iteratorError4 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
              _iterator4["return"]();
            }
          } finally {
            if (_didIteratorError4) {
              throw _iteratorError4;
            }
          }
        }

        map.clear();
      }
    }, 0);
  }

  if (!map) map = queue[depth] = new Map();else if (map.has(memory)) return;
  map.set(memory, function () {
    var content = transform(memory);

    var _elm$3 = _slicedToArray(elm[''], 1),
        children = _elm$3[0];

    var index = children.indexOf(memory);
    var sibling = ~index ? locate(children.slice(index + 1)) : undefined;
    reconcile(memory, content, elm, memory, sibling);
  });
}

var characters = {
  '&': '&amp;',
  '"': '&quot;',
  '\'': '&#39;',
  '<': '&lt;',
  '>': '&gt;'
};

function escape(string) {
  if (typeof string !== 'string') return string;
  return string.replace(/[&"'<>]/g, function (match) {
    return characters[match];
  });
}

var cache = new WeakMap();

function parse(strings) {
  for (var _len = arguments.length, variables = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    variables[_key - 1] = arguments[_key];
  }

  var outline = {};

  if (!variables.length) {
    if (cache.has(strings)) return cache.get(strings);
    cache.set(strings, outline);
  }

  var text = '',
      content = [],
      memory;
  var symbol = '<';
  var stack = [content];
  var _iteratorNormalCompletion5 = true;
  var _didIteratorError5 = false;
  var _iteratorError5 = undefined;

  try {
    for (var _iterator5 = strings[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
      var string = _step5.value;

      while (string.length) {
        var index = string.indexOf(symbol);

        if (~index) {
          if (symbol === '<') {
            text += string.slice(0, index);
            if (text) content.push({
              '': [text]
            });
            symbol = (_readOnlyError("symbol"), '>');
            stack.unshift(content = []);
          } else {}
        } else {
          var variable = variables.shift();
        }
      }
    }
  } catch (err) {
    _didIteratorError5 = true;
    _iteratorError5 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion5 && _iterator5["return"] != null) {
        _iterator5["return"]();
      }
    } finally {
      if (_didIteratorError5) {
        throw _iteratorError5;
      }
    }
  }

  if (!variables) return outline;
}

var singletons = ['wbr', 'track', 'source', 'param', 'meta', 'link', 'keygen', 'input', 'img', 'hr', 'embed', 'command', 'col', 'br', 'base', 'area', '!doctype'];

function scribe(outline, sibling) {
  if (Array.isArray(outline)) {
    outline = {
      '': [outline]
    };
  } else if (!outline && outline !== 0 || outline === true || typeof outline === 'function') {
    return '';
  } else if (_typeof(outline) !== 'object') {
    var value = escape(outline);
    if (sibling && !sibling.startsWith('<')) value += '<!-- -->';
    return value;
  }

  var _outline = outline,
      _outline$ = _slicedToArray(_outline[''], 3),
      content = _outline$[0],
      tag = _outline$[2],
      props = _objectWithoutProperties(_outline, [""]);

  var tags = [];
  var children = [];

  if (typeof tag === 'function') {
    content = tag(_objectSpread({}, props, {
      '': {}
    }), content);

    if (!Array.isArray(content)) {
      content = content === undefined ? [] : [content];
    }
  } else if (tag) {
    var attr = Object.entries(props).map(function (_ref2) {
      var _ref3 = _slicedToArray(_ref2, 2),
          name = _ref3[0],
          value = _ref3[1];

      if (!/^[a-zA-Z0-9-_.]+$/.test(name) || !value && value !== 0) {
        return '';
      }

      if (name === 'style') {
        value = Object.entries(value).map(function (_ref4) {
          var _ref5 = _slicedToArray(_ref4, 2),
              name = _ref5[0],
              value = _ref5[1];

          if (!/^[a-zA-Z0-9-_.]+$/.test(name)) return '';
          name = name.replace(/[A-Z]/g, function (x) {
            return "-".concat(x.toLowerCase());
          });
          return "".concat(name, ":").concat(escape(value), ";");
        }).join('');
      } else if (name.startsWith('on')) {
        value = 'javascript:void(0);';
      } else if (Array.isArray(value)) {
        value = value.filter(function (it) {
          return it && typeof it === 'string';
        }).join(' ');
      } else if (_typeof(value) === 'object') {
        return '';
      } else {
        value = escape(value);
      }

      return value === true ? name : "".concat(name, "=\"").concat(value, "\"");
    }, '');
    if (attr.length) attr = " ".concat(attr.filter(function (value) {
      return value;
    }).join(' '));
    tags.push("<".concat(tag).concat(attr, ">"));
    if (~singletons.indexOf(tag)) content = [];else tags.push("</".concat(tag, ">"));
  }

  content.reduceRight(function (sibling, it, i) {
    return (children[i] = scribe(it, sibling)) || sibling;
  }, sibling);
  tags.splice.apply(tags, [tags.length && 1, 0].concat(children));
  return tags.join('');
}

function compare(prev, it, key) {
  if (it === prev) {
    return true;
  } else if (key || _typeof(it) !== 'object' || _typeof(prev) !== 'object' || Array.isArray(it) !== Array.isArray(prev)) {
    return false;
  } else if (Array.isArray(it)) {
    if (it.length !== prev.length) return false;
    return it.every(function (it, i) {
      return compare(prev[i], it);
    });
  }

  var entries = Object.entries(it);
  if (entries.length !== Object.keys(prev).length) return false;
  return entries.every(function (_ref6) {
    var _ref7 = _slicedToArray(_ref6, 2),
        key = _ref7[0],
        value = _ref7[1];

    return compare(prev[key], value, key);
  });
}

function create(tag, elm, ctx) {
  var content = tag === undefined ? ctx : [],
      memory,
      ref,
      nodes;

  if (typeof tag === 'function') {
    var callback = function callback(input) {
      switch (_typeof(input)) {
        case 'string':
          {
            var _node$;

            if (!input) return locate(memory[''][0]);

            var _ref8 = ref[input] || {},
                _ref8$ = _ref8[''];

            _ref8$ = _ref8$ === void 0 ? [] : _ref8$;

            var _ref8$2 = _slicedToArray(_ref8$, 3),
                node = _ref8$2[1],
                _tag = _ref8$2[2];

            if (typeof _tag !== 'function') return node;

            for (var _len2 = arguments.length, rest = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
              rest[_key2 - 1] = arguments[_key2];
            }

            return rest.length ? (_node$ = node[''])[''].apply(_node$, rest) : undefined;
          }

        case 'undefined':
          return depth;

        case 'object':
          break;

        default:
          return;
      }

      var type = input[''],
          props = _objectWithoutProperties(input, [""]);

      Object.assign(state, props);
      trigger(memory, elm);
    };

    var state = {
      '': callback
    };
    var depth = ctx ? ctx[''][1]['']['']() + 1 : 0;
    ref = {
      '': state
    };
  } else if (tag !== '') {
    var _ref9 = elm || {},
        _ref9$ = _ref9[''];

    _ref9$ = _ref9$ === void 0 ? [] : _ref9$;

    var _ref9$2 = _slicedToArray(_ref9$, 4),
        _ref9$2$ = _ref9$2[3],
        dom = _ref9$2$ === void 0 ? [] : _ref9$2$;

    if (dom.length && (tag || dom[dom.length - 1] instanceof Text)) {
      ref = dom.pop();

      if (ref instanceof Element) {
        nodes = _toConsumableArray(ref.childNodes).filter(function (_ref10) {
          var nodeType = _ref10.nodeType;
          return nodeType !== Node.COMMENT_NODE;
        });
      } else if (tag) {
        ref = dom.pop();
      }
    }

    if (!ref) {
      if (tag) ref = document.createElement(tag);else ref = document.createTextNode(content);
    }
  }

  return memory = {
    '': [content, ref, tag, nodes]
  };
}

function modify(memory, props, content) {
  var _memory$5 = _slicedToArray(memory[''], 3),
      text = _memory$5[0],
      node = _memory$5[1],
      tag = _memory$5[2],
      attributes = _objectWithoutProperties(memory, [""]);

  if (!tag) {
    if (!content && content !== 0 || content === true) content = '';
    if (content !== text) node.nodeValue = memory[''][0] = content;
    return;
  }

  for (var _i2 = 0, _Object$keys = Object.keys(_objectSpread({}, attributes, {}, props)); _i2 < _Object$keys.length; _i2++) {
    var name = _Object$keys[_i2];
    var value = props[name];
    var prev = attributes[name];

    if (prev === value) {
      continue;
    } else if (name.startsWith('on')) {
      name = name.slice(2);
      if (prev) node.removeEventListener(name, prev);
      if (value) node.addEventListener(name, value);
    } else if (value === true) {
      node.toggleAttribute(name, true);
    } else if (!value && value !== '' && value !== 0) {
      node.removeAttribute(name);
    } else if (name === 'style') {
      var style = node.style;
      if (!prev) prev = {};

      for (var _i3 = 0, _Object$keys2 = Object.keys(_objectSpread({}, prev, {}, value)); _i3 < _Object$keys2.length; _i3++) {
        var _name = _Object$keys2[_i3];
        var rule = value[_name];
        if (rule !== prev[_name]) style[_name] = rule;
      }
    } else {
      if (Array.isArray(value)) {
        value = value.filter(function (it) {
          return it && typeof it === 'string';
        }).join(' ');
      }

      node.setAttribute(name, value);
    }
  }

  Object.assign(memory, props);
}

function transform(memory, props, content) {
  var core = memory[''],
      prev = _objectWithoutProperties(memory, [""]);

  var _core = _slicedToArray(core, 3),
      state = _core[1][''],
      type = _core[2];

  if (props) {
    if (compare(prev, props) && compare(core[3], content)) return;
    var map = queue[state['']()];
    if (map) map["delete"](memory);
    Object.assign(memory, props);
    core[3] = content;
  }

  var result = type(_objectSpread({}, memory, {
    '': state
  }), core[3]);
  if (Array.isArray(result)) return result;
  return result === undefined ? [] : [result];
}

function update(memory, container, i, elm, ctx, sibling) {
  var _ref11 = container || {},
      _ref11$ = _ref11[''];

  _ref11$ = _ref11$ === void 0 ? [] : _ref11$;

  var _ref11$2 = _slicedToArray(_ref11$, 1),
      _ref11$2$ = _ref11$2[0],
      children = _ref11$2$ === void 0 ? [] : _ref11$2$;

  var _memory3 = memory,
      _memory3$ = _slicedToArray(_memory3[''], 3),
      content = _memory3$[0],
      key = _memory3$[1],
      tag = _memory3$[2],
      props = _objectWithoutProperties(_memory3, [""]);

  var targeted = ctx && key && typeof key === 'string';
  memory = targeted ? ctx[''][1][key] : children[i];

  if (!memory || tag !== memory[''][2]) {
    memory = create(tag, elm, tag ? ctx : content);
    if (targeted) ctx[''][1][key] = memory;
  }

  if (typeof tag === 'function') {
    content = transform(memory, props, content);
    ctx = memory;
  } else if (tag !== '') {
    sibling = modify(memory, props, content);
    elm = memory;
  }

  if (Array.isArray(content)) reconcile(memory, content, elm, ctx, sibling);
  return memory;
}

function stew(first) {
  for (var _len3 = arguments.length, rest = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
    rest[_key3 - 1] = arguments[_key3];
  }

  if (Array.isArray(first)) {
    return parse.apply(void 0, [first].concat(rest));
  } else if (_typeof(first) !== 'object') {
    var _ref12 = rest.shift() || {},
        _key4 = _ref12[''],
        _props = _objectWithoutProperties(_ref12, [""]);

    return _objectSpread({
      '': [rest, _key4, first || '']
    }, _props);
  }

  var _first$ = first[''],
      node = _first$ === void 0 ? 'div' : _first$,
      props = _objectWithoutProperties(first, [""]);

  if (typeof node === 'string') return scribe(stew.apply(void 0, [node, props].concat(rest)));else if (!(node instanceof Element)) return;
  var tagName = node.tagName,
      childNodes = node.childNodes;
  var tag = tagName.toLowerCase();
  var elm = {
    '': [[], node, tag, _toConsumableArray(childNodes)]
  };
  return update(stew.apply(void 0, [tag, props].concat(rest)), elm, 0, elm);
}

			if (typeof define === 'function' && define.amd) {
			define(function () { return stew; });
		} else if (typeof module !== 'undefined' && module.exports) {
			module.exports = stew;
		} else if (typeof window === 'object' && window.document) {
			window.stew = stew;
		}
		})();