(() => {
  // src/activate.js
  var impulses = [];
  var queue = /* @__PURE__ */ new Set();
  var effects = /* @__PURE__ */ new Set();
  var resets = [];
  var timeout;
  function screen(impulse) {
    const { parentImpulse } = impulse;
    if (!parentImpulse)
      return false;
    if (queue.has(parentImpulse))
      return true;
    return screen(parentImpulse);
  }
  function schedule(subscriptions) {
    if (frameworks[0]?.[0] === virtualDocument)
      return;
    if (typeof subscriptions === "function") {
      effects.add(subscriptions);
    } else {
      for (const impulse of subscriptions) {
        queue.add(impulse);
      }
    }
    timeout = timeout !== void 0 ? timeout : setTimeout(() => {
      const resetsCopy = resets.splice(0);
      const effectsCopy = [...effects];
      const queueCopy = [...queue];
      effects.clear();
      queue.clear();
      timeout = void 0;
      for (const effect of effectsCopy) {
        effect();
      }
      for (const impulse of queueCopy) {
        const isCovered = screen(impulse);
        if (isCovered)
          continue;
        impulse();
      }
      for (const [state, name] of resetsCopy) {
        state[name] = void 0;
      }
    }, 0);
  }
  function unsubscribe(impulses2) {
    if (!Array.isArray(impulses2)) {
      impulses2.view.memos[0].impulse = void 0;
      impulses2 = [impulses2];
    }
    for (const impulse of impulses2) {
      if (impulse.view.memos[0].impulse)
        continue;
      const { subscriptionsSet, childImpulses, view: { memos } } = impulse;
      const [{ teardowns }] = memos;
      for (const subscriptions of subscriptionsSet) {
        subscriptions.delete(impulse);
      }
      for (const index of teardowns) {
        const [teardown, ...prevDeps] = memos[index];
        if (typeof teardown === "function")
          teardown(prevDeps);
      }
      subscriptionsSet.clear();
      unsubscribe(childImpulses);
    }
  }
  function useMemo(callback, deps, cueCount) {
    const memos = impulses[0]?.view?.memos || [{}];
    const [options] = memos;
    let memo = memos[options.index];
    let prevDeps, persist;
    if (memo) {
      prevDeps = memo.splice(1);
      persist = deps && deps.length === prevDeps?.length && deps.every((it, i) => {
        return it === prevDeps[i] || i < cueCount && it === void 0;
      });
    } else {
      memo = [];
    }
    if (!persist) {
      try {
        memo[0] = callback(memo[0], prevDeps);
      } catch (e) {
        console.error(e);
      }
    }
    if (deps)
      memo.push(...deps);
    memos[options.index++] = memo;
    return memo[0];
  }
  function useEffect(...params) {
    const [{ view: { memos } }] = impulses;
    const [{ index, teardowns }] = memos;
    schedule(() => {
      useMemo(...params);
      teardowns.push(index);
    });
    return memos[index];
  }
  function useImpulse(callback, ...rest) {
    return useMemo(([prevValue, view] = [], prevDeps = []) => {
      return activate(callback, prevValue, [view, ...prevDeps], -2);
    }, ...rest)[0];
  }
  function createState(object, ...rest) {
    const state = Array.isArray(object) ? [] : {};
    const key = /^string|number$/.test(typeof rest[0]) ? rest.shift() : void 0;
    const cues = Array.isArray(rest[0]) ? rest.shift() : [];
    const cuesObject = Object.fromEntries(cues.map((cue) => [cue]));
    const entries = Object.entries({ ...cuesObject, ...object });
    if (frameworks[0]?.[0] === virtualDocument) {
      return Object.assign(state, Object.fromEntries(entries));
    }
    for (let [name, value] of entries) {
      const isCue = ~cues.indexOf(name);
      const subscriptions = /* @__PURE__ */ new Set();
      if (typeof value === "function") {
        value = value.bind(state);
      }
      Object.defineProperty(state, name, {
        get() {
          if (impulses.length) {
            const [impulse] = impulses;
            subscriptions.add(impulse);
            impulse.subscriptionsSet.add(subscriptions);
          }
          return value;
        },
        set(newValue) {
          if (newValue === value)
            return;
          value = newValue;
          if (isCue) {
            if (value === void 0)
              return;
            resets.push([state, name]);
          }
          schedule(subscriptions);
          subscriptions.clear();
        }
      });
    }
    return key === void 0 ? state : Object.defineProperty(state, key, { value: state, writeable: false });
  }
  function activate(callback, state, parentView, i, dom = {}, hydrateNodes) {
    const [framework] = frameworks;
    const [parentImpulse] = impulses;
    const childImpulses = [];
    const view = parentView?.[i + 2] || [];
    const sibling = { ...dom };
    let params = [];
    let initialized = false;
    function impulse(newState) {
      frameworks.unshift(framework);
      impulses.unshift(impulse);
      unsubscribe(childImpulses.splice(0));
      Object.assign(view.memos[0], { index: 1, teardowns: [] });
      if (newState)
        state = newState;
      let outline;
      try {
        outline = callback(state, ...params);
      } catch (e) {
        console.error(e);
      }
      if (i < 0) {
        outline = [outline, view];
      } else if (i !== void 0) {
        if (initialized)
          dom = { ...sibling };
        reconcile(outline, state, parentView, i, dom, hydrateNodes);
        const newView = parentView[i + 2];
        if (newView !== view) {
          if (view.length)
            remove(view, dom.container);
          view.splice(0, view.length, ...newView);
          parentView[i + 2] = view;
        }
      } else if (parentView[0]) {
        const [, updater, defaultProps] = framework;
        update(parentView[0], outline, updater, defaultProps);
      } else {
        for (const impulse2 of parentView.childImpulses) {
          impulse2(outline);
        }
      }
      impulses.shift();
      frameworks.shift();
      return outline;
    }
    Object.assign(impulse, {
      parentImpulse,
      childImpulses,
      view,
      subscriptionsSet: /* @__PURE__ */ new Set()
    });
    parentImpulse?.childImpulses?.push?.(impulse);
    if (i >= 0)
      parentView?.childImpulses?.push?.(impulse);
    if (!view.memos)
      view.memos = [{ teardowns: [] }];
    const prevImpulse = view.memos[0].impulse;
    if (prevImpulse && prevImpulse !== impulse)
      unsubscribe(prevImpulse);
    if (i < 0) {
      params = parentView.slice(i + 3);
      view.memos[0].impulse = impulse;
    }
    const value = impulse();
    Object.assign(dom, { sibling });
    hydrateNodes = void 0;
    initialized = true;
    return value;
  }

  // src/reconcile.js
  var managedProps = /* @__PURE__ */ new WeakMap();
  function append(node, dom) {
    const { container } = dom;
    let sibling;
    while (dom && !sibling) {
      ({ node: sibling, sibling: dom } = dom);
    }
    if (sibling)
      container.insertBefore(node, sibling);
    else
      container.appendChild(node);
  }
  function remove(view, container) {
    let [node, , ...childViews] = view;
    if (node && container) {
      container.removeChild(node);
      container = void 0;
    }
    for (const childView of childViews) {
      remove(childView, container);
    }
  }
  function populate(outlines, state, view, dom, hydrateNodes) {
    const [, keyedViews, ...childViews] = view;
    for (let i = outlines.length - 1; i >= 0; i--) {
      const staticView = reconcile(outlines[i], state, view, i, dom, hydrateNodes);
      if (staticView)
        staticView.memos = void 0;
    }
    const { container } = dom;
    view.splice(outlines.length + 2);
    for (const childView of childViews) {
      if (!childView?.length || view.indexOf(childView) > 1)
        continue;
      remove(childView, container);
    }
    const entries = Object.entries(keyedViews);
    const validEntries = entries.filter(([, childView]) => view.indexOf(childView) > 1);
    if (validEntries.length !== entries.length)
      view[1] = Object.fromEntries(keyedEntries);
  }
  function write(text, view = [], dom) {
    const nodeValue = String(text);
    let [node] = view;
    if (!node || !("nodeValue" in node)) {
      const [[document]] = frameworks;
      node = document.createTextNode(nodeValue);
      append(node, dom);
      return [node];
    }
    if (nodeValue !== node.nodeValue)
      node.nodeValue = nodeValue;
    return view;
  }
  function update(node, attributes, updater, defaultProps) {
    const prevNames = managedProps.get(node);
    updater(node, attributes, prevNames, defaultProps[node.tagName.toLowerCase()]);
    managedProps.set(node, Object.keys(attributes));
  }
  function process(outline, state, parentView, i, dom, hydrateNodes) {
    if (!outline && outline !== 0) {
      return [];
    } else if (typeof outline === "object" && !Array.isArray(outline)) {
      append(outline, dom);
      return [outline];
    }
    const [, keyedViews] = parentView;
    let view = hydrateNodes ? hydrateNodes.slice(-1) : parentView[i + 2];
    if (outline === true) {
      if (hydrateNodes)
        view[1] = {};
      return view || [];
    } else if (!Array.isArray(outline)) {
      const textView = write(outline, view, dom);
      if (hydrateNodes && textView === view)
        hydrateNodes.pop();
      return textView;
    }
    let [str, obj, ...arr] = outline;
    let [, tagName, key] = str.match(/^\s*(.*?)\s*(?::(.*?))?$/);
    if (hydrateNodes)
      view[1] = {};
    else
      view = keyedViews?.[key] || view || [, {}];
    let [node] = view;
    if (tagName === "") {
      if (node || view.length < 2)
        view = [, {}];
      view.childImpulses = [];
      if (typeof obj === "function")
        obj = activate(obj, state, view);
      if (obj)
        state = obj;
    } else {
      const [[document, updater, defaultProps]] = frameworks;
      tagName = tagName.toLowerCase();
      if (view.length < 2 || tagName !== node?.tagName?.toLowerCase?.()) {
        if (!Object.prototype.hasOwnProperty.call(defaultProps, tagName)) {
          const example = document.createElement(tagName);
          defaultProps[tagName] = example;
        }
        node = document.createElement(tagName);
        view = [node, {}];
        append(node, dom);
      } else if (hydrateNodes) {
        hydrateNodes.pop();
      }
      if (typeof obj === "function")
        activate(obj, state, view);
      else if (obj)
        update(node, obj, updater, defaultProps);
      dom = { container: node };
      if (hydrateNodes) {
        hydrateNodes = [...node.childNodes];
      }
    }
    if (key)
      keyedViews[key] = view;
    populate(arr, state, view, dom, hydrateNodes);
    return view;
  }
  function reconcile(outline, state, parentView, i, dom, hydrateNodes) {
    if (typeof outline === "function") {
      activate(outline, state, parentView, i, dom, hydrateNodes);
      return;
    }
    const sibling = { ...dom };
    const view = process(outline, state, parentView, i, dom, hydrateNodes);
    let [node] = parentView[i + 2] = view;
    if (!node && dom.node !== sibling.node)
      node = dom.node;
    if (node)
      Object.assign(dom, { node, sibling: void 0 });
    return view;
  }

  // src/index.js
  var selfClosingTags = /* @__PURE__ */ new Set([
    "wbr",
    "track",
    "source",
    "param",
    "meta",
    "link",
    "keygen",
    "input",
    "img",
    "hr",
    "embed",
    "command",
    "col",
    "br",
    "base",
    "area",
    "!doctype"
  ]);
  var nameMap = {
    className: "class"
  };
  var virtualDocument = {
    createTextNode(nodeValue) {
      return {
        nodeValue,
        toString() {
          return this.nodeValue;
        }
      };
    },
    createDocumentFragment() {
      return {
        childNodes: [],
        appendChild(child) {
          this.removeChild(child);
          this.childNodes.push(child);
          child.parentElement = this;
        },
        insertBefore(child, sibling) {
          const { childNodes } = this;
          this.removeChild(child);
          const index = childNodes.indexOf(sibling);
          childNodes.splice(index, 0, child);
          child.parentElement = this;
        },
        removeChild(child) {
          const { childNodes } = this;
          const index = childNodes.indexOf(child);
          if (index === -1)
            return;
          childNodes.splice(index, 1);
          child.parentElement = null;
        },
        toString() {
          return this.childNodes.join("");
        }
      };
    },
    createElement(tagName) {
      const fragment = this.createDocumentFragment();
      return Object.assign(fragment, {
        tagName,
        style: {},
        toString() {
          const {
            appendChild,
            insertBefore,
            removeChild,
            toString,
            tagName: tagName2,
            style,
            childNodes,
            parentElement,
            ...attributes
          } = this;
          let html = `<${tagName2 === "!doctype" ? "!DOCTYPE" : tagName2}`;
          for (let [name, value] of Object.entries(attributes)) {
            if (!value && value !== 0 || typeof value === "function")
              continue;
            name = nameMap[name] || name.replace(/(?=[A-Z])/g, "-").toLowerCase();
            html += ` ${name}="${value === true ? "" : value}"`;
          }
          const styleString = Object.entries(style).map(([name, value]) => {
            return `${name}:${value}`;
          }).join(";");
          if (styleString)
            html += ` style="${styleString}"`;
          if (selfClosingTags.has(tagName2.toLowerCase()))
            return `${html}>`;
          return `${html}>${this.childNodes.join("")}</${tagName2}>`;
        }
      });
    }
  };
  function defaultUpdater(element, props, prevNames, defaultProps) {
    prevNames = new Set(prevNames);
    const changes = Object.entries(props).filter(([name, value]) => {
      prevNames.delete(name);
      const currentValue = ~name.indexOf("-") ? element.getAttribute(name) : element[name];
      return value !== currentValue;
    });
    for (const name of prevNames) {
      const defaultValue = ~name.indexOf("-") ? defaultElement.getAttribute(name) : defaultProps[name];
      changes.push([name, defaultValue]);
    }
    for (const [name, value] of changes) {
      if (name === "style") {
        const entries = Object.entries(value);
        const { style } = element;
        for (const [name2, value2] of entries) {
          if (style[name2] === String(value2))
            continue;
          style[name2] = value2;
        }
      } else if (!~name.indexOf("-")) {
        element[name] = value;
      } else if (value === void 0 || value === null) {
        element.removeAttribute(name);
      } else {
        element.setAttribute(name, value === true ? "" : value);
      }
    }
  }
  var frameworks = [];
  var defaultDocument = typeof window === "object" && window.document || virtualDocument;
  var defaultFramework = [defaultDocument, defaultUpdater, {}];
  var virtualFramework = [virtualDocument, defaultUpdater, {}];
  function stew(container, outline, framework = defaultFramework) {
    if (typeof container === "string") {
      const [document] = framework;
      if (!("querySelector" in document))
        return;
      container = document.querySelector(container);
    }
    const view = [container, {}];
    const dom = { container };
    const hydrateNodes = [...container.childNodes];
    frameworks.unshift(framework);
    reconcile(outline, {}, view, 0, dom, hydrateNodes);
    frameworks.shift();
    for (const node of hydrateNodes) {
      container.removeChild(node);
    }
  }
  function createElement(tagName, attributes, layout) {
    const container = defaultDocument.createElement(tagName);
    if (layout !== void 0)
      stew(container, layout);
    if (attributes !== void 0)
      defaultUpdater(container, attributes);
    return container;
  }
  Object.assign(stew, {
    useMemo,
    useEffect,
    useImpulse,
    createState,
    createElement,
    virtualFramework
  });
  if (typeof window === "object") {
    window.stew = stew;
  } else if (typeof module === "object") {
    module.exports = stew;
  }
})();
