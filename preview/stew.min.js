(() => {
  // src/execute.js
  var contexts = /* @__PURE__ */ new WeakMap();
  var documents = [];
  var updaters = [];
  var callbacks = [];
  function useEffect(callback) {
    const [contextCallback] = callbacks;
    const context = contexts.get(contextCallback);
    if (!context || context.document.ignoreHooks?.has?.(useEffect))
      return;
    const { ref, teardowns } = context;
    const hasMounted = !!ref;
    const teardown = callback();
    if (teardown)
      teardowns.push(teardown);
  }
  function execute(callback, ...context) {
    if (context.length) {
      context.unshift({
        parentCallback: callbacks[0],
        customDocument: documents[0],
        customUpdater: updaters[0]
      });
      contexts.set(callback, context);
    } else {
      context = contexts.get(callback);
      if (!context)
        return;
    }
    let [options, state, containerRef, i, prevRefs, container, sibling] = context;
    const { customDocument, customUpdater } = options;
    options.teardowns = [];
    documents.unshift(customDocument);
    updaters.unshift(customUpdater);
    callbacks.unshift(callback);
    let item;
    try {
      item = callback(state, containerRef[i + 2]);
    } catch (e) {
      console.error(e);
    }
    sibling = reconcile(item, state, containerRef, i, prevRefs, container, sibling);
    context[4] = containerRef[1];
    documents.shift();
    updaters.shift();
    callbacks.shift();
    return sibling;
  }

  // src/observe.js
  var queue = /* @__PURE__ */ new Set();
  var timeout;
  function screen(callback) {
    const { parentCallback } = contexts.get(callback) || {};
    if (!parentCallback)
      return false;
    if (queue.has(parentCallback))
      return true;
    return screen(parentCallback);
  }
  function schedule(subscriptions) {
    for (const callback of subscriptions.splice(0)) {
      const isQueued = queue.has(callback) || screen(callback);
      if (isQueued)
        continue;
      queue.add(callback);
    }
    timeout = timeout !== void 0 ? timeout : setTimeout(() => {
      for (const callback of queue) {
        execute(callback);
      }
      queue.clear();
      timeout = void 0;
    }, 0);
  }
  function observe(object) {
    const state = {};
    for (let [name, value] of Object.entries(object)) {
      const subscriptions = [];
      if (typeof value === "function") {
        value = value.bind(state);
      }
      Object.defineProperty(state, name, {
        get() {
          subscriptions.push(callbacks[0]);
          return value;
        },
        set(newValue) {
          value = newValue;
          schedule(subscriptions);
        }
      });
    }
    return state;
  }

  // src/reconcile.js
  function clean(container, prevIndexedRefs, indexedRefs) {
  }
  function append(container, node, sibling) {
    if (node.parentElement)
      return;
    let siblingNode;
    while (sibling && !siblingNode) {
      const { node: node2, next } = sibling;
      siblingNode = node2;
      sibling = next;
    }
    if (siblingNode)
      container.insertBefore(node, siblingNode);
    else
      container.appendChild(node);
  }
  function populate(items, state, ref, prevRefs, container, sibling) {
    const prevIndexedRefs = ref.slice(2);
    const originalSibling = sibling;
    let [node] = ref;
    const isFragment = node !== container;
    if (!isFragment)
      sibling = void 0;
    for (let i = items.length - 1; i >= 0; i--) {
      sibling = reconcile(items[i], state, ref, i, prevRefs, container, sibling);
    }
    clean(container, prevIndexedRefs, ref.slice(2));
    if (sibling === originalSibling)
      return sibling;
    if (isFragment)
      node = sibling.node;
    return { node, next: originalSibling };
  }
  function reconcile(item, state, containerRef, i, prevRefs, container, sibling) {
    if (!item && item !== 0 || item === true) {
      containerRef[i + 2] = void 0;
      return sibling;
    } else if (typeof item === "function") {
      return execute(item, state, containerRef, i, prevRefs, container, sibling);
    } else if (typeof item === "object" && !Array.isArray(item)) {
      containerRef[i + 2] = item;
      append(container, item, sibling);
      return { node: item, next: sibling };
    }
    const isHydrating = Array.isArray(prevRefs);
    let [, keyedRefs, ...indexedRefs] = containerRef;
    let ref = isHydrating ? prevRefs[prevRefs.length - 1] : indexedRefs[i];
    let node;
    if (!Array.isArray(item)) {
      const nodeValue = String(item);
      if (!ref || !("nodeValue" in ref)) {
        ref = documents[0].createTextNode(nodeValue);
        append(container, ref, sibling);
      } else {
        if (isHydrating)
          prevRefs.pop();
        if (nodeValue !== ref.nodeValue)
          ref.nodeValue = nodeValue;
      }
      containerRef[i + 2] = ref;
      return { node: ref, next: sibling };
    }
    const [str, obj, ...arr] = item;
    const [, tagName, key] = str.match(/^\s*(.*?)\s*(?::(.*?))?$/);
    const isFragment = tagName === "";
    if (isHydrating)
      ref = isFragment || !ref ? [] : [ref];
    else if (!ref)
      ref = prevRefs[key] || [, {}];
    node = ref?.[0];
    if (isFragment) {
      node = { state: obj };
      if (obj)
        node.state = state = observe(obj);
    } else {
      if (node?.tagName?.toLowerCase?.() !== tagName.toLowerCase()) {
        node = documents[0].createElement(tagName);
        append(container, node, sibling);
      } else if (isHydrating) {
        prevRefs.pop();
      }
      if (obj)
        updaters[0](node, obj);
      const { childNodes } = container = node;
      if (isHydrating) {
        prevRefs = [...childNodes];
      }
    }
    if (key)
      keyedRefs[key] = ref;
    const prevRefCore = ref.splice(0, 2, node, {});
    if (!isHydrating)
      [, prevRefs] = prevRefCore;
    containerRef[i + 2] = ref;
    return populate(arr, state, ref, prevRefs, container, sibling);
  }

  // src/index.js
  var selfClosingTags = /* @__PURE__ */ new Set([
    "wbr",
    "track",
    "source",
    "param",
    "meta",
    "link",
    "keygen",
    "input",
    "img",
    "hr",
    "embed",
    "command",
    "col",
    "br",
    "base",
    "area",
    "!doctype"
  ]);
  var nameMap = {
    className: "class"
  };
  var virtualDocument = {
    createTextNode(nodeValue) {
      return {
        nodeValue,
        toString() {
          return this.nodeValue;
        }
      };
    },
    createDocumentFragment() {
      return {
        childNodes: [],
        appendChild(child) {
          this.childNodes.push(child);
        },
        insertBefore(child, sibling) {
          const { childNodes } = this;
          const index = childNodes.indexOf(sibling);
          childNodes.splice(index, 0, child);
        },
        toString() {
          return this.childNodes.join("");
        }
      };
    },
    createElement(tagName) {
      const fragment = this.createDocumentFragment();
      return Object.assign(fragment, {
        tagName,
        toString() {
          const { childNodes, appendChild, toString, ...attributes } = this;
          let html = `<${tagName}`;
          for (let [name, value] of Object.entries(attributes)) {
            if (!value && value !== 0 || typeof value === "function")
              continue;
            name = nameMap[name] || name.replace(/(?=[A-Z])/g, "-").toLowerCase();
            html += ` ${name}="${value === true ? "" : value}"`;
          }
          if (selfClosingTags.has(tagName.toLowerCase()))
            return `${html}>`;
          return `${html}>${this.childNodes.join("")}</${tagName}>`;
        }
      });
    }
  };
  var defaultDocument = typeof window === "object" && window.document || virtualDocument;
  function defaultUpdater(node, attributes) {
    for (const [name, value] of Object.entries(attributes)) {
      if (node[name] === value)
        continue;
      node[name] = value;
    }
  }
  function stew(container, outline, state = {}, document = defaultDocument, updater = defaultUpdater) {
    if (!container) {
      container = document.createElement("div");
    } else if (typeof container !== "object") {
      container = document.querySelector(container);
    }
    const { childNodes = [] } = container;
    documents.unshift(document);
    updaters.unshift(updater);
    reconcile(outline, state, [container, {}], 0, [...childNodes], container);
    documents.shift();
    updaters.unshift();
    return container;
  }
  Object.assign(stew, { useEffect, virtualDocument });
  if (typeof window === "object") {
    window.stew = stew;
  } else if (typeof module === "object") {
    module.exports = stew;
  }
})();
