(() => {
  // src/view/dom.js
  var selfClosingTags = /* @__PURE__ */ new Set([
    "wbr",
    "track",
    "source",
    "param",
    "meta",
    "link",
    "keygen",
    "input",
    "img",
    "hr",
    "embed",
    "command",
    "col",
    "br",
    "base",
    "area",
    "!doctype"
  ]);
  var nameMap = {
    className: "class",
    tabIndex: "tabindex"
  };
  var virtualDocument = {
    createTextNode(nodeValue) {
      return {
        nodeValue,
        toString() {
          return this.nodeValue;
        }
      };
    },
    createDocumentFragment() {
      return {
        childNodes: [],
        appendChild(child) {
          this.removeChild(child);
          this.childNodes.push(child);
          child.parentElement = this;
        },
        insertBefore(child, sibling) {
          const { childNodes } = this;
          this.removeChild(child);
          const index = childNodes.indexOf(sibling);
          childNodes.splice(index, 0, child);
          child.parentElement = this;
        },
        removeChild(child) {
          const { childNodes } = this;
          const index = childNodes.indexOf(child);
          if (index === -1)
            return;
          childNodes.splice(index, 1);
          child.parentElement = null;
        },
        toString() {
          return this.childNodes.join("");
        }
      };
    },
    createElement(tagName) {
      const fragment = this.createDocumentFragment();
      return Object.assign(fragment, {
        tagName,
        style: {},
        toString() {
          const {
            appendChild,
            insertBefore,
            removeChild,
            toString,
            tagName: tagName2,
            style,
            childNodes,
            parentElement,
            ...attributes
          } = this;
          let html = `<${tagName2 === "!doctype" ? "!DOCTYPE" : tagName2}`;
          for (let [name, value] of Object.entries(attributes)) {
            if (!value && value !== 0 || typeof value === "function")
              continue;
            name = nameMap[name] || name.replace(/(?=[A-Z])/g, "-").toLowerCase();
            html += ` ${name}="${value === true ? "" : value}"`;
          }
          const styleString = Object.entries(style).map(([name, value]) => {
            return `${name}:${value}`;
          }).join(";");
          if (styleString)
            html += ` style="${styleString}"`;
          if (selfClosingTags.has(tagName2.toLowerCase()))
            return `${html}>`;
          return `${html}>${this.childNodes.join("")}</${tagName2}>`;
        }
      });
    }
  };
  function defaultUpdater(element, props, prevNames, defaultProps, ignoreRef) {
    prevNames = new Set(prevNames);
    const changes = Object.entries(props).filter(([name, value]) => {
      prevNames.delete(name);
      const currentValue = ~name.indexOf("-") ? element.getAttribute(name) : element[name];
      return value !== currentValue;
    });
    for (const name of prevNames) {
      const defaultValue = ~name.indexOf("-") ? defaultElement.getAttribute(name) : defaultProps[name];
      changes.push([name, defaultValue]);
    }
    for (const [name, value] of changes) {
      if (name === "ref") {
        if (ignoreRef)
          continue;
        if (typeof value === "function")
          value(element);
        else if (Array.isArray(value))
          value.unshift(element);
      } else if (name === "style") {
        const entries = Object.entries(value);
        const { style } = element;
        for (const [name2, value2] of entries) {
          if (style[name2] === String(value2))
            continue;
          style[name2] = value2;
        }
      } else if (!~name.indexOf("-")) {
        element[name] = value;
      } else if (value === void 0 || value === null) {
        element.removeAttribute(name);
      } else {
        element.setAttribute(name, value === true ? "" : value);
      }
    }
  }
  var frameworks = [];
  var isClient = typeof window === "object";
  var defaultDocument = isClient && window.document || virtualDocument;
  var defaultFramework = [defaultDocument, defaultUpdater, {}];
  var dom_default = [virtualDocument, defaultUpdater, {}];
  Object.assign(defaultFramework, { isServer: !isClient });

  // src/view/element.js
  var managedProps = /* @__PURE__ */ new WeakMap();
  function processText(text, view = []) {
    const nodeValue = String(text);
    let [node] = view;
    if (!node || !("nodeValue" in node)) {
      const [[document]] = frameworks;
      node = document.createTextNode(nodeValue);
      return [node];
    }
    if (nodeValue !== node.nodeValue)
      node.nodeValue = nodeValue;
    return view;
  }
  function processElement(tagName, obj, view) {
    const [framework] = frameworks;
    const [document, updater, defaultProps] = framework;
    let [node] = view;
    if (!("keyedViews" in view) || tagName !== node?.tagName?.toLowerCase?.()) {
      if (!Object.prototype.hasOwnProperty.call(defaultProps, tagName)) {
        const example = document.createElement(tagName);
        defaultProps[tagName] = example;
      }
      node = document.createElement(tagName);
      view = Object.assign([node], { keyedViews: {} });
    }
    if (obj) {
      const prevNames = managedProps.get(node);
      updater(node, obj, prevNames, defaultProps[node.tagName.toLowerCase()]);
      managedProps.set(node, Object.keys(obj));
    }
    return view;
  }

  // src/view/index.js
  function appendNode(node, dom) {
    const { container, sibling } = dom;
    if (sibling && sibling.previousSibling !== node) {
      container.insertBefore(node, sibling);
    } else if (!sibling && container.lastChild !== node) {
      container.appendChild(node);
    }
  }
  function removeNode(view, container) {
    let [node, ...childViews] = view;
    if (node) {
      container.removeChild(node);
      return;
    }
    for (const childView of childViews) {
      removeNode(childView, container);
    }
  }
  function prepareCandidate(candidates, dom) {
    if (!candidates.length)
      return;
    const [candidate] = dom.candidate = Object.assign(candidates?.splice?.(-1), { keyedViews: {} });
    return candidate;
  }
  function populateChildren(infos, state, parentFiber, parentView, dom) {
    const { container, candidates, doAppend } = dom;
    const [, ...childViews] = parentView;
    let candidate = prepareCandidate(candidates || [], dom);
    parentView.splice(infos.length + 1);
    for (let i = infos.length - 1; i >= 0; i--) {
      const prevView = parentView[i + 1];
      const view = reconcileNode(infos[i], state, parentFiber, parentView, i, dom);
      const [node] = parentView[i + 1] = view;
      if (!node) {
        view.sibling = dom.sibling;
        continue;
      } else if (node === candidate) {
        candidate = prepareCandidate(candidates, dom);
      } else if (doAppend || node !== prevView?.[0]) {
        appendNode(node, dom);
      }
      dom.sibling = node;
    }
    for (const childView of childViews) {
      if (!childView?.length || parentView.indexOf(childView) > 0)
        continue;
      removeNode(childView, container);
    }
    const entries = Object.entries(parentView.keyedViews);
    const validEntries = entries.filter(([, childView]) => parentView.indexOf(childView) > 0);
    if (validEntries.length !== entries.length)
      parentView.keyedViews = Object.fromEntries(validEntries);
    Object.assign(dom, { doAppend: false, candidates: void 0 });
  }
  function reconcileNode(info, state, parentFiber, parentView, i, dom) {
    const { candidate = parentView[i + 1], candidates, doAppend } = dom;
    if (!Array.isArray(info)) {
      switch (typeof info) {
        case "function": {
          if (frameworks[0]?.isServer) {
            info = executeCallback(info, state);
            return reconcileNode(info, state, parentFiber, parentView, i, dom);
          }
          return processFiber(info, state, parentFiber, parentView, i, dom);
        }
        case "object":
          return [info];
        case "string":
        case "number":
          return processText(info, candidate);
        default:
          return info && candidate || [];
      }
    }
    const [str, obj, ...arr] = info;
    const hasKey = ~str.indexOf(":");
    const [, tagName, key] = hasKey ? str.match(/^\s*(.*?)\s*(?::(.*?))?$/) : [, str];
    let view = !candidates && hasKey && parentView.keyedViews[key] || candidate || [];
    let [node] = view;
    if (tagName === "") {
      if (node || !("keyedViews" in view))
        view = Object.assign([], { keyedViews: {} });
      if (obj)
        state = obj;
      if (!doAppend)
        dom.doAppend = view !== candidate;
    } else {
      [node] = view = processElement(tagName.toLowerCase(), obj, view);
      dom = { container: node };
      if (candidates)
        dom.candidates = [...node.childNodes];
    }
    if (hasKey)
      parentView.keyedViews[key] = view;
    populateChildren(arr, state, parentFiber, view, dom);
    dom.doAppend = doAppend;
    return view;
  }

  // src/state/fiber.js
  var fibers = [];
  function deactivateFiber(fiber) {
    const { view, memos, teardowns, registry } = fiber;
    view.fiber = void 0;
    for (const subscriptions of registry) {
      subscriptions.delete(fiber);
    }
    for (const childFiber of fiber.slice(1)) {
      deactivateFiber(childFiber);
    }
    for (const index of teardowns) {
      const [teardown, ...prevDeps] = memos[index];
      if (typeof teardown === "function")
        teardown(prevDeps);
    }
  }
  function executeCallback(callback, ...params) {
    try {
      return callback(...params);
    } catch (e) {
      console.error(e);
    }
  }
  function processFiber(callback, state, parentFiber, parentView, i, dom) {
    let fiber = parentView[i + 1]?.fiber;
    if (!fiber) {
      let impulse = function() {
        frameworks.unshift(framework);
        fibers.unshift(fiber);
        Object.assign(fiber, { index: 0, teardowns: [] });
        const { callback: callback2, state: state2 } = fiber;
        const oldChildFibers = fiber.splice(1);
        const info = executeCallback(callback2, state2);
        if (prevView)
          dom.sibling = parentView.slice(i + 1).find((view2) => view2[0] || view2.sibling)?.[0];
        const view = fiber.view = reconcileNode(info, state2, fiber, parentView, i, dom);
        view.fiber = fiber;
        if (prevView) {
          if (view !== prevView) {
            removeNode(prevView, dom.container);
            parentView[i + 1] = view;
          }
          for (const childFiber of oldChildFibers) {
            if (!~fiber.indexOf(childFiber))
              deactivateFiber(childFiber);
          }
        }
        fibers.shift();
        frameworks.shift();
        impulse.queued = false;
        return prevView = view;
      };
      const [framework] = frameworks;
      let prevView;
      fiber = Object.assign([impulse], { depth: fibers.length, memos: [], registry: /* @__PURE__ */ new Set() });
    }
    parentFiber.push(fiber);
    Object.assign(fiber, { callback, state });
    return fiber[0](state);
  }

  // src/state/index.js
  var effects = [];
  var queue = /* @__PURE__ */ new Set();
  var resets = [];
  var animationFrame;
  function scheduleDispatches(subscriptions) {
    for (const fiber of subscriptions) {
      queue.add(fiber);
    }
    if (animationFrame)
      return;
    requestAnimationFrame(() => {
      const resetsCopy = resets.splice(0);
      const queueLayers = {};
      for (const fiber of [...queue]) {
        const { 0: impulse, depth } = fiber;
        const queueLayer = queueLayers[depth];
        if (queueLayer)
          queueLayer.push(impulse);
        else
          queueLayers[depth] = [impulse];
        fiber[0].queued = true;
      }
      queue.clear();
      animationFrame = void 0;
      for (const effect of effects.splice(0)) {
        effect();
      }
      for (const i of Object.keys(queueLayers).sort((a, b) => a - b)) {
        for (const impulse of queueLayers[i]) {
          if (impulse.queued)
            impulse();
        }
      }
      for (const [state, name] of resetsCopy) {
        state[name] = void 0;
      }
    });
  }
  function createState(object, key) {
    const state = Array.isArray(object) ? [] : {};
    const cues = key !== void 0 && object[key] || [];
    const cuesObject = Object.fromEntries(cues.map((cue) => [cue]));
    const entries = Object.entries({ ...cuesObject, ...object });
    if (frameworks[0]?.isServer) {
      Object.assign(state, Object.fromEntries(entries.splice(0)));
    }
    for (let [name, value] of entries) {
      if (name === key)
        continue;
      const isCue = ~cues.indexOf(name);
      const subscriptions = /* @__PURE__ */ new Set();
      if (typeof value === "function") {
        value = value.bind(state);
      }
      Object.defineProperty(state, name, {
        get() {
          if (fibers.length) {
            const [fiber] = fibers;
            subscriptions.add(fiber);
            fiber.registry.add(subscriptions);
          }
          return value;
        },
        set(newValue) {
          if (newValue === value)
            return;
          value = newValue;
          if (isCue) {
            if (value === void 0)
              return;
            resets.push([state, name]);
          }
          scheduleDispatches(subscriptions);
          subscriptions.clear();
        }
      });
    }
    if (key === void 0)
      return state;
    return Object.defineProperty(state, key, { value: state, writeable: false });
  }

  // src/state/hooks.js
  function useMemo(callback, deps, ...rest) {
    if (frameworks[0]?.isServer)
      return executeCallback(callback, void 0, void 0);
    const cueCount = rest.length && typeof rest[0] !== "function" ? rest.shift() : 0;
    const [callbackOnPersist] = rest;
    const [fiber] = fibers;
    const { memos, index } = fiber || [];
    let memo = memos?.[index];
    let prevDeps, persist;
    if (memo) {
      prevDeps = memo.splice(1);
      persist = deps && deps.length === prevDeps?.length && deps.every((it, i) => {
        return it === prevDeps[i] || i < cueCount && it === void 0;
      });
    } else {
      memo = [];
    }
    if (!persist)
      memo[0] = executeCallback(callback, memo[0], prevDeps);
    if (deps)
      memo.push(...deps);
    if (fiber)
      memos[fiber.index++] = memo;
    return persist && callbackOnPersist ? callbackOnPersist(memo[0]) : memo[0];
  }
  function useEffect(...params) {
    if (frameworks[0].isServer)
      return;
    const [fiber] = fibers;
    const { memos, index, teardowns } = fiber;
    effects.push(() => {
      fibers.unshift(fiber);
      useMemo(...params);
      fibers.shift();
      teardowns.push(index);
    });
    scheduleDispatches([]);
    return memos[index];
  }
  function useState(...params) {
    const key = /^string|number$/.test(typeof params[0]) ? params.shift() : void 0;
    let object = params.shift();
    return useMemo((...params2) => {
      if (typeof object === "function")
        object = executeCallback(object, ...params2);
      return createState(object, key);
    }, ...params);
  }

  // src/index.js
  function stew(container, layout, framework = defaultFramework) {
    const isFragment = container === "";
    if (typeof container === "string") {
      const [document] = framework;
      if (isFragment)
        container = document.createDocumentFragment();
      else if (!("querySelector" in document))
        return;
      else
        container = document.querySelector(container);
    }
    const fiber = [,];
    const view = Object.assign([container], { keyedViews: {} });
    const candidates = framework.isServer ? void 0 : [...container.childNodes];
    const dom = { container, candidates };
    frameworks.unshift(framework);
    reconcileNode(["", null, layout], {}, fiber, view, 0, dom);
    frameworks.shift();
    if (candidates) {
      for (const node of candidates) {
        container.removeChild(node);
      }
    }
    if (isFragment)
      return container;
  }

  // src/main.js
  Object.assign(stew, {
    virtualFramework: dom_default,
    useMemo,
    useEffect,
    useState
  });
  if (typeof window === "object") {
    window.stew = stew;
  } else if (typeof module === "object") {
    module.exports = stew;
  }
  var main_default = stew;
})();
/**
 * @license MIT
 * Copyright (c) 2023 Jeff Triplett
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
