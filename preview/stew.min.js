(() => {
  // src/observe.js
  var record = /* @__PURE__ */ new WeakMap();
  var queue = /* @__PURE__ */ new Set();
  var timeout;
  function screen(impulse) {
    if (queue.has(impulse))
      return true;
    const { parentImpulse } = impulse;
    return !!parentImpulse && screen(parentImpulse);
  }
  function schedule(subscriptions) {
    if (frameworks[0]?.[0] === virtualDocument)
      return;
    for (const impulse of subscriptions.splice(0)) {
      const isQueued = screen(impulse);
      if (isQueued)
        continue;
      queue.add(impulse);
    }
    timeout = timeout !== void 0 ? timeout : setTimeout(() => {
      for (const impulse of queue) {
        impulse();
      }
      queue.clear();
      timeout = void 0;
    }, 0);
  }
  function observe(object) {
    const state = {};
    const changes = {};
    record.set(state, changes);
    for (let [name, value] of Object.entries(object)) {
      const subscriptions = [];
      if (typeof value === "function") {
        value = value.bind(state);
      }
      Object.defineProperty(state, name, {
        get() {
          subscriptions.push(impulses[0]);
          return value;
        },
        set(newValue) {
          if (newValue === value)
            return;
          changes[name] = value = newValue;
          schedule(subscriptions);
        }
      });
    }
    return state;
  }

  // src/execute.js
  var teardowns = /* @__PURE__ */ new WeakMap();
  var frameworks = [];
  var impulses = [];
  function execute(callback, state, parentView, i, dom, hydrateNodes = []) {
    const isEffect = i === void 0 && parentView[0] === void 0;
    const [framework] = frameworks;
    function impulse(hydrateNodes2) {
      frameworks.unshift(framework);
      impulses.unshift(impulse);
      let viewParam = [];
      let item;
      if (isEffect) {
        viewParam = teardowns.has(parentView) ? record.get(state) : void 0;
      }
      try {
        item = callback(state, viewParam);
      } catch (e) {
        console.error(e);
      }
      if (i !== void 0) {
        const domCopy = { ...dom };
        const prevView = parentView[i + 2];
        reconcile(item, state, parentView, i, dom, hydrateNodes2);
        dom = domCopy;
        if (!hydrateNodes2 && prevView?.length && parentView[i + 2] !== prevView) {
          const { container } = dom;
          remove(prevView, container);
        }
        const newView = parentView[i + 2];
        if (newView)
          viewParam.push(...newView);
      } else {
        const [node] = parentView;
        if (node) {
          const [, updater] = framework;
          updater(node, item);
        } else {
          teardowns.set(parentView, item);
        }
      }
      impulses.shift();
      frameworks.shift();
    }
    if (isEffect) {
      schedule([impulse]);
      return;
    }
    impulse.parentImpulse = impulses[0];
    impulse(hydrateNodes);
  }

  // src/reconcile.js
  function append(node, dom) {
    if (node.parentElement)
      return;
    const { container } = dom;
    let sibling;
    while (dom && !sibling) {
      ({ node: sibling, sibling: dom } = dom);
    }
    if (sibling)
      container.insertBefore(node, sibling);
    else
      container.appendChild(node);
  }
  function remove(view, container) {
    if (teardowns.has(view)) {
      const teardown = teardowns.get(view);
      if (typeof teardown === "function")
        teardown();
    }
    let [node, , ...childViews] = view;
    if (node) {
      container.removeChild(node);
      return;
    }
    for (const childView of childViews) {
      remove(childView, container);
    }
  }
  function populate(items, state, view, dom, hydrateNodes) {
    const prevChildren = view.slice(2);
    for (let i = items.length - 1; i >= 0; i--) {
      reconcile(items[i], state, view, i, dom, hydrateNodes);
    }
    const { container } = dom;
    view.splice(items.length + 2);
    for (const childView of prevChildren) {
      if (!childView?.length || view.indexOf(childView) > 1)
        continue;
      remove(childView, container);
    }
  }
  function write(text, view = [], dom, hydrateNodes) {
    const nodeValue = String(text);
    let [node] = view;
    if (!node || !("nodeValue" in node)) {
      node = frameworks[0][0].createTextNode(nodeValue);
      append(node, dom);
      return [node];
    }
    if (hydrateNodes)
      hydrateNodes.pop();
    if (nodeValue !== node.nodeValue)
      node.nodeValue = nodeValue;
    return view;
  }
  function update(item, state, parentView, i, dom, hydrateNodes) {
    if (!item && item !== 0 || item === true) {
      return [];
    } else if (typeof item === "object" && !Array.isArray(item)) {
      append(item, dom);
      return [item];
    }
    let [futureViews, pastViews, ...views] = parentView;
    let view = hydrateNodes ? hydrateNodes.slice(-1) : views[i];
    if (!Array.isArray(item)) {
      return write(item, view, dom, hydrateNodes);
    }
    const [str, obj, ...arr] = item;
    const [, tagName, key] = str.match(/^\s*(.*?)\s*(?::(.*?))?$/);
    const isFragment = tagName === "";
    if (!view)
      view = pastViews?.[key] || [];
    let node;
    if (!isFragment) {
      [node] = view;
      if (node?.tagName?.toLowerCase?.() !== tagName.toLowerCase()) {
        view[0] = node = frameworks[0][0].createElement(tagName);
        append(node, dom);
      }
      if (typeof obj === "function")
        execute(obj, state, view);
      else if (obj)
        frameworks[0][1](node, obj);
      dom = { container: node };
      if (hydrateNodes) {
        const { childNodes } = node;
        hydrateNodes.pop();
        hydrateNodes = [...childNodes];
      }
    } else if (typeof obj === "function") {
      execute(obj, state, view);
    } else if (obj) {
      state = observe(obj);
    }
    if (key)
      futureViews[key] = view;
    futureViews = view[0] = {};
    populate(arr, state, view, dom, hydrateNodes);
    view.splice(0, 2, node, futureViews);
    return view;
  }
  function reconcile(item, state, parentView, i, dom, hydrateNodes) {
    if (typeof item === "function") {
      execute(item, state, parentView, i, dom, hydrateNodes);
      return;
    }
    const sibling = { ...dom };
    const view = update(item, state, parentView, i, dom, hydrateNodes);
    let [node] = parentView[i + 2] = view;
    if (!node && dom.node !== sibling.node)
      node = dom.node;
    if (node)
      Object.assign(dom, { node, sibling });
  }

  // src/index.js
  var selfClosingTags = /* @__PURE__ */ new Set([
    "wbr",
    "track",
    "source",
    "param",
    "meta",
    "link",
    "keygen",
    "input",
    "img",
    "hr",
    "embed",
    "command",
    "col",
    "br",
    "base",
    "area",
    "!doctype"
  ]);
  var nameMap = {
    className: "class"
  };
  var virtualDocument = {
    createTextNode(nodeValue) {
      return {
        nodeValue,
        toString() {
          return this.nodeValue;
        }
      };
    },
    createDocumentFragment() {
      return {
        childNodes: [],
        appendChild(child) {
          this.removeChild(child);
          this.childNodes.push(child);
          child.parentElement = this;
        },
        insertBefore(child, sibling) {
          const { childNodes } = this;
          this.removeChild(child);
          const index = childNodes.indexOf(sibling);
          childNodes.splice(index, 0, child);
          child.parentElement = this;
        },
        removeChild(child) {
          const { childNodes } = this;
          const index = childNodes.indexOf(child);
          if (index === -1)
            return;
          childNodes.splice(index, 1);
          child.parentElement = null;
        },
        toString() {
          return this.childNodes.join("");
        }
      };
    },
    createElement(tagName) {
      const fragment = this.createDocumentFragment();
      return Object.assign(fragment, {
        tagName,
        toString() {
          const { childNodes, appendChild, toString, ...attributes } = this;
          let html = `<${tagName}`;
          for (let [name, value] of Object.entries(attributes)) {
            if (!value && value !== 0 || typeof value === "function")
              continue;
            name = nameMap[name] || name.replace(/(?=[A-Z])/g, "-").toLowerCase();
            html += ` ${name}="${value === true ? "" : value}"`;
          }
          if (selfClosingTags.has(tagName.toLowerCase()))
            return `${html}>`;
          return `${html}>${this.childNodes.join("")}</${tagName}>`;
        }
      });
    }
  };
  var defaultDocument = typeof window === "object" && window.document || virtualDocument;
  function defaultUpdater(node, attributes) {
    for (const [name, value] of Object.entries(attributes)) {
      if (node[name] === value)
        continue;
      node[name] = value;
    }
  }
  function create(selector, document) {
    const [tagName, ...strings] = String(selector).split(/(?=\.|\[)/);
    const node = document.createElement(tagName);
    const classList = [];
    for (const string of strings) {
      if (string.startsWith(".")) {
        classList.push(string.slice(1));
        continue;
      }
      const [, name, value] = string.match(/^\[\s*([^=[]*?)\s*(?:=([^[]*))?\]/);
      if (!name)
        continue;
      node[name] = value || true;
    }
    node.className = classList.join(" ");
  }
  function stew(container, outline, document = defaultDocument, updater = defaultUpdater) {
    if (typeof container !== "object") {
      container = document?.querySelector?.(container) || create(container, document);
    }
    const { childNodes } = container;
    frameworks.unshift([document, updater]);
    reconcile(outline, {}, [container, {}], 0, { container }, [...childNodes]);
    frameworks.shift();
    return container;
  }
  Object.assign(stew, { document: virtualDocument });
  if (typeof window === "object") {
    window.stew = stew;
  } else if (typeof module === "object") {
    module.exports = stew;
  }
})();
