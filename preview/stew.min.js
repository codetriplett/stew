(() => {
  // src/execute.js
  var contexts = /* @__PURE__ */ new WeakMap();
  var documents = [];
  var updaters = [];
  var callbacks = [];
  function useEffect(callback) {
    const [contextCallback] = callbacks;
    const context = contexts.get(contextCallback);
    if (!context || context.document.ignoreHooks?.has?.(useEffect))
      return;
    const { ref, teardowns } = context;
    const hasMounted = !!ref;
    const teardown = callback();
    if (teardown)
      teardowns.push(teardown);
  }
  function execute(callback, ...params) {
    let context, item, state, containerRef, i, container, childNodes, oldKeyedRefs;
    if (params.length) {
      context = {
        parentCallback: callbacks[0],
        customDocument: documents[0],
        customUpdater: updaters[0],
        ref: [, {}]
      };
      contexts.set(callback, [context, ...params]);
    } else {
      [context, ...params] = contexts.get(callback) || [];
    }
    if (!context)
      return;
    let { customDocument, customUpdater, ref } = context;
    [state, containerRef, i, container, childNodes, oldKeyedRefs] = params;
    context.teardowns = [];
    documents.unshift(customDocument);
    updaters.unshift(customUpdater);
    callbacks.unshift(callback);
    try {
      item = callback(state, ref);
    } catch (e) {
      console.error(e);
    }
    [oldKeyedRefs] = containerRef.splice(1, 1, {});
    ref = reconcile(item, state, containerRef, i, container, childNodes, oldKeyedRefs);
    documents.shift();
    updaters.shift();
    callbacks.shift();
    context.childNodes = [];
    return context.ref = ref;
  }

  // src/observe.js
  var queue = /* @__PURE__ */ new Set();
  var timeout;
  function screen(callback) {
    const { parentCallback } = contexts.get(callback) || {};
    if (!parentCallback)
      return false;
    if (queue.has(parentCallback))
      return true;
    return screen(parentCallback);
  }
  function schedule(subscriptions) {
    for (const callback of subscriptions.splice(0)) {
      const isQueued = queue.has(callback) || screen(callback);
      if (isQueued)
        continue;
      queue.add(callback);
    }
    timeout = timeout !== void 0 ? timeout : setTimeout(() => {
      for (const callback of queue) {
        execute(callback);
      }
      queue.clear();
      timeout = void 0;
    }, 0);
  }
  function observe(object) {
    const state = {};
    for (let [name, value] of Object.entries(object)) {
      const subscriptions = [];
      if (typeof value === "function") {
        value = value.bind(state);
      }
      Object.defineProperty(state, name, {
        get() {
          subscriptions.push(callbacks[0]);
          return value;
        },
        set(newValue) {
          value = newValue;
          schedule(subscriptions);
        }
      });
    }
    return state;
  }

  // src/reconcile.js
  function clean(ref, oldKeyedRefs, oldIndexedRefs) {
    const [, newKeyedRefs, ...newIndexedRefs] = ref;
  }
  function process(item, state, containerRef, i, container, childNodes, oldKeyedRefs) {
    const isHydrating = !oldKeyedRefs;
    let [, keyedRefs, ...indexedRefs] = containerRef;
    let ref = isHydrating ? childNodes[0] : indexedRefs[i];
    if (!Array.isArray(item)) {
      const nodeValue = String(item);
      if (!ref || !("nodeValue" in ref)) {
        ref = documents[0].createTextNode(nodeValue);
      } else {
        childNodes.shift();
        if (nodeValue !== ref.nodeValue)
          ref.nodeValue = nodeValue;
      }
      return ref;
    }
    const [str, obj, ...arr] = item;
    const [, tagName, key] = str.match(/^\s*(.*?)\s*(?::(.*?))?$/);
    const isFragment = tagName === "";
    if (isHydrating)
      ref = isFragment || !ref ? [] : [ref];
    else if (!ref)
      ref = oldKeyedRefs[key] || [, {}];
    let node = ref?.[0];
    if (isFragment) {
      node = { state: obj };
      if (obj)
        node.state = state = observe(obj);
    } else {
      if (node?.tagName?.toLowerCase?.() !== tagName.toLowerCase()) {
        node = documents[0].createElement(tagName);
      } else {
        childNodes.shift();
      }
      if (obj)
        updaters[0](node, obj);
      container = node;
      childNodes = [...node.childNodes];
    }
    if (key)
      keyedRefs[key] = ref;
    [, oldKeyedRefs] = ref.splice(0, 2, node, {});
    for (const [i2, childItem] of arr.entries()) {
      reconcile(childItem, state, ref, i2, container, childNodes, oldKeyedRefs);
    }
    clean(ref, oldKeyedRefs, indexedRefs);
    return ref;
  }
  function reconcile(item, state, containerRef, i, container, childNodes, oldKeyedRefs) {
    let ref = item;
    if (!item && item !== 0 || item === true) {
      ref = void 0;
    } else if (typeof item === "function") {
      ref = execute(item, state, containerRef, i, container, childNodes, oldKeyedRefs);
    } else if (typeof item !== "object" || Array.isArray(item)) {
      ref = process(item, state, containerRef, i, container, childNodes, oldKeyedRefs);
    }
    const node = Array.isArray(ref) ? ref[0] : ref;
    if (node && ("tagName" in node || "nodeValue" in node)) {
      const [sibling] = childNodes;
      if (sibling)
        container.insertBefore(node, sibling);
      else
        container.appendChild(node);
    }
    return containerRef[i + 2] = ref;
  }

  // src/index.js
  var selfClosingTags = /* @__PURE__ */ new Set([
    "wbr",
    "track",
    "source",
    "param",
    "meta",
    "link",
    "keygen",
    "input",
    "img",
    "hr",
    "embed",
    "command",
    "col",
    "br",
    "base",
    "area",
    "!doctype"
  ]);
  var nameMap = {
    className: "class"
  };
  var virtualDocument = typeof window === "object" && window.document || {
    createTextNode(nodeValue) {
      return {
        nodeValue,
        toString() {
          return this.nodeValue;
        }
      };
    },
    createDocumentFragment() {
      return {
        childNodes: [],
        appendChild(child) {
          this.childNodes.push(child);
        },
        insertBefore(child, sibling) {
          const { childNodes } = this;
          const index = childNodes.indexOf(sibling);
          childNodes.splice(index, 0, child);
        },
        toString() {
          return this.childNodes.join("");
        }
      };
    },
    createElement(tagName) {
      const fragment = this.createDocumentFragment();
      return Object.assign(fragment, {
        tagName,
        toString() {
          const { childNodes, appendChild, toString, ...attributes } = this;
          let html = `<${tagName}`;
          for (let [name, value] of Object.entries(attributes)) {
            if (!value && value !== 0 || typeof value === "function")
              continue;
            name = nameMap[name] || name.replace(/(?=[A-Z])/g, "-").toLowerCase();
            html += ` ${name}="${value === true ? "" : value}"`;
          }
          if (selfClosingTags.has(tagName.toLowerCase()))
            return `${html}>`;
          return `${html}>${this.childNodes.join("")}</${tagName}>`;
        }
      });
    }
  };
  function defaultUpdater(node, attributes) {
    for (const [name, value] of Object.entries(attributes)) {
      if (node[name] === value)
        continue;
      node[name] = value;
    }
  }
  function stew(container, outline, state = {}, document = virtualDocument, updater = defaultUpdater) {
    if (!container) {
      container = document.createElement("div");
    } else if (typeof container !== "object") {
      container = document.querySelector(container);
    }
    const { childNodes = [] } = container;
    documents.unshift(document);
    updaters.unshift(updater);
    reconcile(outline, state, [container, {}], 0, container, [...childNodes]);
    documents.shift();
    updaters.unshift();
    return container;
  }
  Object.assign(stew, { useEffect, virtualDocument });
  if (typeof window === "object") {
    window.stew = stew;
  } else if (typeof module === "object") {
    module.exports = stew;
  }
})();
